{"remainingRequest":"/Users/krystalmarie/Desktop/Thor/projects/3790-final-vue-project-krystal-mitchell/node_modules/babel-loader/lib/index.js!/Users/krystalmarie/Desktop/Thor/projects/3790-final-vue-project-krystal-mitchell/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/Users/krystalmarie/Desktop/Thor/projects/3790-final-vue-project-krystal-mitchell/node_modules/vuetify/lib/util/mergeData.js","mtime":1571087452256},{"path":"/Users/krystalmarie/Desktop/Thor/projects/3790-final-vue-project-krystal-mitchell/node_modules/cache-loader/dist/cjs.js","mtime":1566420493308},{"path":"/Users/krystalmarie/Desktop/Thor/projects/3790-final-vue-project-krystal-mitchell/node_modules/babel-loader/lib/index.js","mtime":1566420490291}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport _defineProperty from \"/Users/krystalmarie/Desktop/Thor/projects/3790-final-vue-project-krystal-mitchell/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\nexport default function mergeData() {\n  var mergeTarget = {};\n  var i = arguments.length;\n  var prop;\n  var event; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (var _i = 0, _Object$keys = Object.keys(arguments[i]); _i < _Object$keys.length; _i++) {\n      prop = _Object$keys[_i];\n\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          } // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n\n\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          var listeners = mergeTarget[prop];\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(arguments[i][prop] || {}); _i2 < _Object$keys2.length; _i2++) {\n            event = _Object$keys2[_i2];\n\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array().concat( // eslint-disable-line\n              listeners[event], arguments[i][prop][event]);\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event];\n            }\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = _objectSpread({}, arguments[i][prop], {}, mergeTarget[prop]);\n          break;\n        // Reassignment strategy (no merge)\n\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}",{"version":3,"sources":["/Users/krystalmarie/Desktop/Thor/projects/3790-final-vue-project-krystal-mitchell/node_modules/vuetify/lib/util/mergeData.js"],"names":["mergeData","mergeTarget","i","arguments","length","prop","event","Object","keys","Array","isArray","concat","undefined","trim","listeners"],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\nexport default function mergeData() {\n  const mergeTarget = {};\n  let i = arguments.length;\n  let prop;\n  let event; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          } // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n\n\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          const listeners = mergeTarget[prop];\n\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array().concat( // eslint-disable-line\n              listeners[event], arguments[i][prop][event]);\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event];\n            }\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = { ...arguments[i][prop],\n            ...mergeTarget[prop]\n          };\n          break;\n        // Reassignment strategy (no merge)\n\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\n//# sourceMappingURL=mergeData.js.map"]}]}